# MUI Table Selection System Documentation

## System Overview

This selection system enables seamless coordination between **map/Gantt components** and **task/resource tables**. The key innovation is **intelligent row ordering**: map selections reorder rows once and establish a new order, while subsequent table selections preserve that order without shuffling rows.

### Core Principles

1. **Map/Gantt selections** → Tasks reorder to top, establishing new order
2. **Table selections** → Order preserved, no row shuffling
3. **User sort** → Clears selection, returns to default behavior
4. **Multi-select** → Ctrl/Cmd + click for additive selection
5. **Range select** → Shift + click for range, Ctrl+Shift for additive range

---

## Architecture

### Selection Context (`Selection - UI.tsx`)
**Location:** `src/Openreach - App/App - Shared Components/MUI - Table/Selection - UI.tsx`

#### State Management

```typescript
// Task selection state
const [selectedTaskIds, setSelectedTaskIds] = useState<string[]>([])
const [selectionSource, setSelectionSource] = useState<'map' | 'table' | null>(null)
const [shouldPrioritizeTasks, setShouldPrioritizeTasks] = useState(false)
const mapOrderedTaskIdsRef = useRef<string[]>([])  // ⚠️ useRef to avoid dependency loop

// Performance optimization: O(1) lookups
const selectedTaskIdsSet = useMemo(() => new Set(selectedTaskIds), [selectedTaskIds])
```

#### Key Pattern: useRef for Order Preservation

**Problem:** Using `useState` for order tracking caused infinite loops
**Solution:** `useRef` stores mutable values without triggering re-renders

```typescript
// ❌ WRONG: Causes infinite loop
const [mapOrderedTaskIds, setMapOrderedTaskIds] = useState<string[]>([])
const getPrioritizedTasks = useCallback((tasks) => {
  // ...reordering logic...
  setMapOrderedTaskIds(reordered.map(t => t.taskId)) // ⚠️ setState in callback
}, [mapOrderedTaskIds]) // ⚠️ Dependency on state being set = infinite loop

// ✅ CORRECT: useRef avoids re-render loop
const mapOrderedTaskIdsRef = useRef<string[]>([])
const getPrioritizedTasks = useCallback((tasks) => {
  // ...reordering logic...
  mapOrderedTaskIdsRef.current = reordered.map(t => t.taskId) // ✅ Mutation, no re-render
}, [shouldPrioritizeTasks, selectedTaskIds]) // ✅ No circular dependency
```

---

## Core Functions

### 1. toggleTaskSelection
**Purpose:** Single-click or Ctrl+click selection

```typescript
toggleTaskSelection(taskId: string, multiSelect: boolean, source: 'map' | 'table')
```

**Behavior:**
- **Map source** → Sets `shouldPrioritizeTasks = true` (enables reordering)
- **Table source** → Sets `shouldPrioritizeTasks = false` (locks order)

**Flow:**
```
Map click:  shouldPrioritizeTasks = TRUE  → Reorder tasks, save new order
Table click: shouldPrioritizeTasks = FALSE → Use preserved order, no shuffle
```

### 2. getPrioritizedTasks
**Purpose:** Reorder tasks or preserve map-established order

```typescript
getPrioritizedTasks(tasks: TaskTableRow[]): TaskTableRow[]
```

**Logic:**
```typescript
// Case 1: Preserve map-established order (table selections)
if (mapOrderedTaskIdsRef.current.length > 0 && !shouldPrioritizeTasks) {
  return reconstructOrderFromRef(tasks, mapOrderedTaskIdsRef.current)
}

// Case 2: Active reordering (map selections)
if (shouldPrioritizeTasks && selectedTaskIds.length > 0) {
  const reordered = moveSelectedToTop(tasks)
  mapOrderedTaskIdsRef.current = reordered.map(t => t.taskId) // Save order
  return reordered
}

// Case 3: No selection or no reordering needed
return tasks // Early return preserves array reference
```

**Critical:** Check `shouldPrioritizeTasks` **before** `selectedTaskIds` to enable early return and prevent unnecessary array operations.

### 3. rangeSelectTasks
**Purpose:** Shift+click range selection

```typescript
rangeSelectTasks(taskId: string, allTaskIds: string[], additive: boolean, source: 'map' | 'table')
```

**Parameters:**
- `additive: true` → Ctrl+Shift (add range to selection)
- `additive: false` → Shift only (replace selection with range)

**Logic:**
```typescript
const lastIndex = allTaskIds.indexOf(lastInteractedTaskId)
const currentIndex = allTaskIds.indexOf(taskId)
const startIndex = Math.min(lastIndex, currentIndex)
const endIndex = Math.max(lastIndex, currentIndex)
const rangeIds = allTaskIds.slice(startIndex, endIndex + 1)

return additive ? [...prev, ...rangeIds] : rangeIds
```

### 4. clearSelectionOnSort
**Purpose:** Reset selection when user manually sorts

```typescript
clearSelectionOnSort()
```

**Effect:**
- Clears `selectedTaskIds`
- Resets `selectionSource` to `null`
- Sets `shouldPrioritizeTasks = false`
- Clears `mapOrderedTaskIdsRef.current`

---

## Hooks for Consumers

### useTaskTableSelection
**For:** Table components that need full selection control

```typescript
const {
  selectedTaskIds,           // Current selection
  isTaskSelected,            // O(1) check if task selected
  toggleTaskSelection,       // Single/multi select
  rangeSelectTasks,          // Shift-click range
  getPrioritizedTasks,       // Reorder/preserve order
  clearSelectionOnSort       // Clear on user sort
} = useTaskTableSelection()
```

### useMapSelection
**For:** Map/Gantt components (simplified interface)

```typescript
const {
  selectTaskFromMap,         // Auto-sets source='map'
  selectMultipleTasksFromMap // Bulk selection
} = useMapSelection()
```

### useResourceSelection
**For:** Resource tables (same pattern as tasks)

```typescript
const {
  selectedResourceIds,
  isResourceSelected,
  toggleResourceSelection,
  rangeSelectResources,
  getPrioritizedResources,
  clearResourceSelectionOnSort
} = useResourceSelection()
```

---

## Implementation Examples

### Example 1: Live Task Panel (Map Integration)
**File:** `src/Openreach - App/App - Shared Components/MUI - Panel Structure/App - Pannels/Live - Task.tsx`

```typescript
const {
  getPrioritizedTasks,
  toggleTaskSelection,
  rangeSelectTasks,
  selectedTaskIds,
  clearSelectionOnSort
} = useTaskTableSelection()

// Apply prioritization after filtering
const filteredRows = useMemo(() => {
  return getPrioritizedTasks(filteredTasks || [])
}, [filteredTasks, getPrioritizedTasks])

// Handle row clicks
const handleCellClick = useCallback((params, event) => {
  const isCtrlPressed = event.ctrlKey || event.metaKey
  const isShiftPressed = event.shiftKey
  
  if (isShiftPressed) {
    event.preventDefault()
    const visibleRowIds = filteredRows.map(row => row.taskId)
    rangeSelectTasks(params.row.taskId, visibleRowIds, isCtrlPressed, 'table')
  } else {
    toggleTaskSelection(params.row.taskId, isCtrlPressed, 'table')
  }
}, [toggleTaskSelection, rangeSelectTasks, filteredRows])

// Clear selection on manual sort
const handleSortModelChange = useCallback((newModel) => {
  clearSelectionOnSort()
  setSortModel(newModel)
}, [clearSelectionOnSort])

// Highlight selected rows
const getRowClassName = useCallback((params) => {
  return selectedTaskIds.includes(params.row.taskId) ? 'selected-row' : ''
}, [selectedTaskIds])
```

### Example 2: Live Map (Selection Source)
**File:** `src/Openreach - App/App - Shared Components/MUI - Panel Structure/App - Pannels/Live - Map.tsx`

```typescript
const { selectTaskFromMap } = useMapSelection()
const { selectedTaskIds } = useSelectionUI()

// Marker click handler
const handleMarkerClick = (event, task) => {
  const isCtrlPressed = event.ctrlKey || event.metaKey
  selectTaskFromMap(task.taskId, isCtrlPressed)  // ✅ Auto-sets source='map'
}

// Check if marker should be highlighted
const selectedSet = useMemo(() => new Set(selectedTaskIds), [selectedTaskIds])
const isSelected = selectedSet.has(task.taskId)
```

### Example 3: Gantt Task Block Click
**File:** `src/Openreach - App/App - Shared Components/MUI - Panel Structure/App - Pannels/Live - Gantt.tsx`

```typescript
const { selectTaskFromMap } = useMapSelection()

// Task block click handler
const handleTaskBlockClick = (event, task) => {
  const isCtrlPressed = event.ctrlKey || event.metaKey
  
  // Select from map source (triggers reordering)
  selectTaskFromMap(task.taskId, isCtrlPressed)
  
  // Also append to filtered list if not present
  if (!filteredTaskIds.has(task.taskId)) {
    onAppendTasks([task])
  }
}
```

---

## User Experience Flow

### Scenario 1: Map → Table Interaction
```
1. User clicks map icon (task RG-123)
   → toggleTaskSelection(RG-123, false, 'map')
   → shouldPrioritizeTasks = TRUE
   
2. getPrioritizedTasks runs
   → Reorders: [RG-123, RG-456, RG-789, ...]
   → Saves to mapOrderedTaskIdsRef.current
   → Table shows RG-123 at top ✅

3. User clicks RG-456 row in table
   → toggleTaskSelection(RG-456, false, 'table')
   → shouldPrioritizeTasks = FALSE
   
4. getPrioritizedTasks runs
   → Uses preserved order from mapOrderedTaskIdsRef
   → NO SHUFFLING, order stays: [RG-123, RG-456, RG-789, ...]
   → Table rows stay in place ✅
```

### Scenario 2: User Sorts Column
```
1. User clicks "Priority" column header
   → handleSortModelChange(newModel)
   → clearSelectionOnSort() called
   
2. Selection cleared
   → selectedTaskIds = []
   → shouldPrioritizeTasks = FALSE
   → mapOrderedTaskIdsRef.current = []
   
3. Table applies user's sort
   → Normal priority sorting takes over
   → No selection highlighting ✅
```

### Scenario 3: Multi-Select from Map
```
1. User Ctrl+clicks 3 map icons
   → selectTaskFromMap(RG-123, true)
   → selectTaskFromMap(RG-456, true)
   → selectTaskFromMap(RG-789, true)
   
2. getPrioritizedTasks runs
   → Moves all 3 to top in reverse order:
     [RG-789, RG-456, RG-123, RG-000, ...]
   → Most recent selection appears first
```

---

## Performance Optimizations

### 1. Set-Based Lookups (O(1))
```typescript
const selectedTaskIdsSet = useMemo(() => new Set(selectedTaskIds), [selectedTaskIds])
const isTaskSelected = (taskId) => selectedTaskIdsSet.has(taskId)  // O(1) vs O(n)
```

### 2. Memoized Callbacks
```typescript
const toggleTaskSelection = useCallback((taskId, multiSelect, source) => {
  // ...logic
}, []) // Empty deps = stable reference, prevents re-renders
```

### 3. Early Returns in getPrioritizedTasks
```typescript
// Return early if no work needed (preserves array reference)
if (!shouldPrioritizeTasks || selectedTaskIds.length === 0) {
  return tasks  // Same reference = no re-render
}
```

### 4. useRef Instead of useState
```typescript
// ✅ useRef: No re-renders, no dependency loops
mapOrderedTaskIdsRef.current = newOrder

// ❌ useState: Triggers re-renders, creates dependency loops
setMapOrderedTaskIds(newOrder)
```

---

## Styling

### Selected Row Highlight
**File:** `src/Openreach - App/App - Shared Components/MUI - Table/MUI Table - Table Shell.tsx`

```typescript
'& .selected-row': {
  backgroundColor: theme.palette.mode === 'dark'
    ? 'rgba(144, 202, 249, 0.12)'  // Blue 200 @ 12% opacity
    : 'rgba(25, 118, 210, 0.08)',   // Blue 700 @ 8% opacity
  '&:hover': {
    backgroundColor: theme.palette.mode === 'dark'
      ? 'rgba(144, 202, 249, 0.18)'
      : 'rgba(25, 118, 210, 0.12)',
  },
}
```

---

## Common Pitfalls & Solutions

### ❌ Pitfall 1: Infinite Loops with useState
```typescript
// WRONG: Creates infinite loop
const [order, setOrder] = useState([])
const getPrioritized = useCallback((tasks) => {
  setOrder(tasks.map(t => t.id))  // ⚠️ setState triggers re-render
}, [order])  // ⚠️ Depends on state being set = loop
```

**✅ Solution:** Use `useRef` for mutable tracking
```typescript
const orderRef = useRef([])
const getPrioritized = useCallback((tasks) => {
  orderRef.current = tasks.map(t => t.id)  // ✅ No re-render
}, [selectedTaskIds])  // ✅ No circular dependency
```

### ❌ Pitfall 2: Wrong Dependency Order
```typescript
// WRONG: Checks selectedTaskIds first
if (selectedTaskIds.length > 0 && !shouldPrioritizeTasks) {
  // This still processes array even when not reordering
}
```

**✅ Solution:** Check flag first for early exit
```typescript
// CORRECT: Check flag first
if (!shouldPrioritizeTasks || selectedTaskIds.length === 0) {
  return tasks  // Early return, preserves array reference
}
```

### ❌ Pitfall 3: Missing source Parameter
```typescript
// WRONG: Defaults to 'table', won't trigger reordering
selectTaskFromMap(taskId)  // Uses default source='table'
```

**✅ Solution:** Always specify source
```typescript
// CORRECT: Explicit source
toggleTaskSelection(taskId, false, 'map')  // ✅ Triggers reordering
```

---

## Quick Reference

### Selection Methods

| Method | Single/Multi | Range | Source | Reorders? |
|--------|--------------|-------|--------|-----------|
| `toggleTaskSelection(id, false, 'map')` | Single | No | Map | ✅ Yes |
| `toggleTaskSelection(id, true, 'map')` | Multi | No | Map | ✅ Yes |
| `toggleTaskSelection(id, false, 'table')` | Single | No | Table | ❌ No |
| `toggleTaskSelection(id, true, 'table')` | Multi | No | Table | ❌ No |
| `rangeSelectTasks(id, ids, false, 'map')` | Replace | Yes | Map | ✅ Yes |
| `rangeSelectTasks(id, ids, true, 'table')` | Additive | Yes | Table | ❌ No |

### State Flags

| Flag | Purpose | Set by |
|------|---------|--------|
| `shouldPrioritizeTasks` | Enable/disable reordering | Map: true, Table: false |
| `selectionSource` | Track selection origin | 'map' or 'table' |
| `mapOrderedTaskIdsRef` | Preserve established order | `getPrioritizedTasks()` |

---

## Future Enhancements

### Potential Improvements
1. **User toggle** - UI button to lock/unlock task order
2. **Clear order button** - Reset to default ordering
3. **Persist order** - Save to localStorage across sessions
4. **Undo/redo** - Selection history with keyboard shortcuts
5. **Bulk actions** - Apply operations to all selected tasks

### Extensibility
- Same pattern works for resource selection (already implemented)
- Can be extended to support grouped selections
- Compatible with virtual scrolling for large datasets
